// Quantum Computing Demo for Matrix Language
// Demonstrates quantum circuit creation, simulation, and visualization

// Create Bell State (maximally entangled 2-qubit state)
let bell = bell_state();
print("Bell state circuit created: ", bell);
print(draw_circuit(bell));

// Simulate the Bell state
let bell_result = simulate(bell);
print("Bell state simulation results:");
print("Execution time: ", bell_result.execution_time);
print("Measurements: ", bell_result.measurements);

// Show the quantum state
print("Final quantum state:");
print(show_state(bell));

// Create a custom 3-qubit GHZ state
let ghz = quantum_circuit(3);
h(ghz, 0);        // Hadamard on qubit 0
cnot(ghz, 0, 1);  // CNOT from 0 to 1
cnot(ghz, 1, 2);  // CNOT from 1 to 2
measure_all(ghz);

print("\nGHZ State Circuit:");
print(draw_circuit(ghz));

// Simulate GHZ state
let ghz_result = simulate(ghz);
print("GHZ state probabilities:", get_probabilities(ghz));

// Demonstrate Bernstein-Vazirani algorithm
let secret = "1011";
let bv_circuit = bernstein_vazirani(secret);
print("\nBernstein-Vazirani Algorithm for secret '", secret, "':");
print(draw_circuit(bv_circuit));

let bv_result = simulate(bv_circuit);
print("BV Algorithm results (should reveal secret):");
print("Measurements: ", bv_result.measurements);

// Demonstrate Grover's Search
let grover_circuit = grover_search(3, [5, 7]);  // Search for items 5 and 7 in 3-qubit space
print("\nGrover's Search Algorithm:");
print(draw_circuit(grover_circuit));

let grover_result = simulate(grover_circuit);
print("Grover search results (should amplify targets 5 and 7):");
print("Final probabilities:", get_probabilities(grover_circuit));

// Demonstrate Quantum Fourier Transform
let qft_circuit = qft(4, false);  // 4-qubit QFT
print("\nQuantum Fourier Transform (4 qubits):");
print(draw_circuit(qft_circuit));

// Create superposition circuit for QFT demo
let superposition = quantum_circuit(4);
h(superposition, 0);
h(superposition, 1);
h(superposition, 2);
h(superposition, 3);

print("Input superposition state:");
print(show_state(simulate(superposition).final_state));

// Apply QFT to superposition
let qft_result = simulate(qft_circuit);
print("After QFT:");
print(show_state(qft_result.final_state));

// Demonstrate quantum state analysis
let analysis_circuit = quantum_circuit(2);
h(analysis_circuit, 0);
cnot(analysis_circuit, 0, 1);  // Create Bell state

let state_info = quantum_state_info(analysis_circuit);
print("\nQuantum State Analysis:");
print("Number of qubits: ", state_info.num_qubits);
print("Is normalized: ", state_info.is_normalized);
print("Von Neumann entropy: ", state_info.entropy);

// Demonstrate parametric gates
let rotation_circuit = quantum_circuit(1);
rx(rotation_circuit, 0, 3.14159/4);  // π/4 rotation around X-axis
ry(rotation_circuit, 0, 3.14159/3);  // π/3 rotation around Y-axis
rz(rotation_circuit, 0, 3.14159/2);  // π/2 rotation around Z-axis
measure(rotation_circuit, 0);

print("\nParametric Rotation Circuit:");
print(draw_circuit(rotation_circuit));

let rotation_result = simulate(rotation_circuit);
print("Rotation result:", rotation_result.measurements);

// Advanced: Create quantum supremacy-inspired circuit
let supremacy_circuit = quantum_circuit(6);

// Layer 1: Hadamard gates
for i in 0..6 {
    h(supremacy_circuit, i);
}

// Layer 2: Random rotations
ry(supremacy_circuit, 0, 0.7854);  // π/4
ry(supremacy_circuit, 1, 1.5708);  // π/2
ry(supremacy_circuit, 2, 0.5236);  // π/6
ry(supremacy_circuit, 3, 1.0472);  // π/3
ry(supremacy_circuit, 4, 2.0944);  // 2π/3
ry(supremacy_circuit, 5, 0.2618);  // π/12

// Layer 3: Entangling gates
cnot(supremacy_circuit, 0, 1);
cnot(supremacy_circuit, 2, 3);
cnot(supremacy_circuit, 4, 5);
cnot(supremacy_circuit, 1, 2);
cnot(supremacy_circuit, 3, 4);

// Layer 4: More rotations
for i in 0..6 {
    rz(supremacy_circuit, i, 0.3927);  // π/8
}

measure_all(supremacy_circuit);

print("\nQuantum Supremacy-Inspired Circuit (6 qubits):");
print("Circuit info: ", circuit_info(supremacy_circuit));
print(draw_circuit(supremacy_circuit));

// Note: This would be computationally intensive for large circuits
// let supremacy_result = simulate(supremacy_circuit);
print("Supremacy circuit created (simulation skipped for performance)");

// Launch Interactive GUI
print("\nLaunching Quantum Simulation Chamber GUI...");
print("Use the interactive interface to explore quantum computing!");
quantum_gui();

print("Quantum computing demonstration completed!");
